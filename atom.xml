<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>kimono koans&#x27; blog!</title>
	<subtitle>kimono koans&#x27; blog!</subtitle>
	<link href="/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="/"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-10-31T00:00:00+00:00</updated>
	<id>/atom.xml</id>
	<entry xml:lang="en">
		<title>New ways to make ZFS&#x2F;btrfs snapshots UNIX-y (again?)</title>
		<published>2022-10-31T00:00:00+00:00</published>
		<updated>2022-10-31T00:00:00+00:00</updated>
		<link rel="alternate" href="/unix/" type="text/html"/>
		<id>/unix/</id>
		<content type="html">&lt;p&gt;One thing I didn&#x27;t understand when I started using ZFS is why there wasn&#x27;t a standard periodic snapshot tool packaged with the filesystem.  Given the triumph of engineering that ZFS is, and the good taste shown in the design of the &lt;code&gt;zfs&lt;&#x2F;code&gt; and &lt;code&gt;zpool&lt;&#x2F;code&gt; utilities, it was hard for me to understand why a standard set of snapshot scripts wasn&#x27;t included everywhere ZFS was used.&lt;&#x2F;p&gt;
&lt;p&gt;One can only guess at a few reasons why.  Maybe the ZFS developers simply wanted a thousand flowers to bloom.  They didn&#x27;t want to impose their strict idea of what a periodic snapshot tool should look like.  Maybe they were simply too busy shipping an OS, and they didn&#x27;t really know, at the time, how snapshots would be used by their consumers.  Perhaps significantly, ZFS was not a &amp;quot;desktop&amp;quot; filesystem until only recently.  Apple missed their opportunity (at eternal glory!).  Ubuntu is now the first mainstream OS most will encounter with ZFS on root.&lt;&#x2F;p&gt;
&lt;p&gt;Of course, not including standard scripts has probably had some positive results.  Through trial and error, I&#x2F;we have created or found snapshot, pruning, replication tools, etc., with which I am&#x2F;we are comfortable.  An ecosystem was allowed to develop in the absence of strict direction.  An ecosystem that developed good tools for one, or a set of jobs, rather than all or too many.&lt;&#x2F;p&gt;
&lt;p&gt;But I think it has had some negative results, as well.  Some very beautiful UNIX-y abstractions have been allowed to languish -- many of us have loads of snapshots, and many of us seem to never use them, except perhaps when we do the occasional rollback, or go hunting for an older version of a file.&lt;&#x2F;p&gt;
&lt;p&gt;Of course, ZFS loves that &amp;quot;most things are a file&amp;quot; for certain operations:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;zfs send rpool&amp;#x2F;scratch@autosnap_2022-10-31_17:01:20_hourly | gzip &amp;gt; &amp;#x2F;srv&amp;#x2F;tmp&amp;#x2F;scratch.gz
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But it seems the ZFS&#x2F;btrfs communities still haven&#x27;t wrapped their collective heads around the idea that snapshot datasets can be useful everywhere, especially at the file (read: not dataset) level.  This is the reason why Jim Salter&#x27;s &lt;code&gt;findoid&lt;&#x2F;code&gt; was such a revelation for me, and a huge inspiration for &lt;code&gt;httm&lt;&#x2F;code&gt;, as it was the first tool I saw which made an attempt to deal with snapshots on a file level.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;httm&lt;&#x2F;code&gt; attempts to take that very broad idea to its logical conclusion.  See:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;asciinema.org&#x2F;a&#x2F;529608&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;asciinema.org&#x2F;a&#x2F;529608.svg&quot; alt=&quot;asciicast&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Of course, &lt;code&gt;httm&lt;&#x2F;code&gt; does lots of neat stuff, on its own, I won&#x27;t describe here.  If your interested in the specifics of &lt;code&gt;httm&lt;&#x2F;code&gt;, please take a look at the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&#x2F;blob&#x2F;master&#x2F;README.md&quot;&gt;README&lt;&#x2F;a&gt;.  I could spend all day (okay, maybe an hour) talking about the things &lt;code&gt;httm&lt;&#x2F;code&gt; does simply by itself.  But what is of most interest is to me is the ways it &lt;em&gt;could be used&lt;&#x2F;em&gt;.  And I&#x27;ve tried to spark some curiosity by showing the very UNIX-y ways I use &lt;code&gt;httm&lt;&#x2F;code&gt;, see for instance &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&#x2F;blob&#x2F;master&#x2F;README.md#example-usage&quot;&gt;to create &lt;code&gt;tar&lt;&#x2F;code&gt; and &lt;code&gt;git&lt;&#x2F;code&gt; archives&lt;&#x2F;a&gt;.  However, shell snippets are just proofs of concept.  What people like me need are fully working scripts&#x2F;models of how &lt;code&gt;httm&lt;&#x2F;code&gt; could be used to do new and interesting and UNIX-y things.&lt;&#x2F;p&gt;
&lt;p&gt;So -- the following are two fully formed (that is, at the limits of my &lt;code&gt;bash&lt;&#x2F;code&gt; script abilities!) examples of how you might use &lt;code&gt;httm&lt;&#x2F;code&gt; to create other new and interesting tools:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&#x2F;blob&#x2F;master&#x2F;scripts&#x2F;ounce.bash&quot;&gt;ounce&lt;&#x2F;a&gt; (codename: &amp;quot;dimebag&amp;quot;) is a wrapper script for httm which give you no mental overhead, non-periodic dynamic snapshots.&lt;&#x2F;p&gt;
&lt;p&gt;When I type &lt;code&gt;ounce nano &#x2F;etc&#x2F;samba&#x2F;smb.conf&lt;&#x2F;code&gt; (I actually &lt;code&gt;alias &#x27;nano&#x27;=&#x27;ounce nano&#x27;&lt;&#x2F;code&gt;), &lt;code&gt;ounce&lt;&#x2F;code&gt; knows that it&#x27;s smart and I&#x27;m dumb, and it sees that I just edited &lt;code&gt;&#x2F;etc&#x2F;samba&#x2F;smb.conf&lt;&#x2F;code&gt; a few short minutes ago and it takes a snapshot before I edit the file again because it wants me to have snapshots of all my file changes.&lt;&#x2F;p&gt;
&lt;p&gt;Of course, we can check:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;➜ httm &amp;#x2F;etc&amp;#x2F;samba&amp;#x2F;smb.conf
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Tue Aug 09 16:46:14 2022  17.6 KiB  &amp;quot;&amp;#x2F;.zfs&amp;#x2F;snapshot&amp;#x2F;autosnap_2022-10-19_20:00:22_hourly&amp;#x2F;etc&amp;#x2F;samba&amp;#x2F;smb.conf&amp;quot;
Fri Oct 21 09:11:17 2022  17.6 KiB  &amp;quot;&amp;#x2F;.zfs&amp;#x2F;snapshot&amp;#x2F;snap_2022-10-21-09:11:18_ounceSnapFileMount&amp;#x2F;etc&amp;#x2F;samba&amp;#x2F;smb.conf&amp;quot;
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Fri Oct 21 09:11:25 2022  17.6 KiB  &amp;quot;&amp;#x2F;etc&amp;#x2F;samba&amp;#x2F;smb.conf&amp;quot;
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&#x2F;tree&#x2F;master&#x2F;scripts&#x2F;bowie.bash&quot;&gt;bowie&lt;&#x2F;a&gt; is a wrapper script for &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&quot;&gt;httm&lt;&#x2F;a&gt; which quickly displays the difference (with colors) between unique snapshot versions and the live file.&lt;&#x2F;p&gt;
&lt;p&gt;A search, in the default, last change mode:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;➜ bowie `which bowie`
&amp;#x2F;usr&amp;#x2F;bin&amp;#x2F;bowie
__
Files &amp;#x2F;.zfs&amp;#x2F;snapshot&amp;#x2F;snap_2022-10-31-08:34:09_ounceSnapFileMount&amp;#x2F;usr&amp;#x2F;bin&amp;#x2F;bowie and &amp;#x2F;usr&amp;#x2F;bin&amp;#x2F;bowie differ
69c69
&amp;lt;		while read line; do
---
&amp;gt;		while read -r line; do
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each script contains has more options and features than can be described here.  I&#x27;m interested in your thoughts on what new options to add, or other potential scripts ideas.  But I&#x27;m even &lt;em&gt;more interested&lt;&#x2F;em&gt; in &lt;em&gt;your scripts&lt;&#x2F;em&gt;, and what new features you&#x27;d like me to add to &lt;code&gt;httm&lt;&#x2F;code&gt; to make new scripts possible&#x2F;better.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;ounce&lt;&#x2F;code&gt; and &lt;code&gt;bowie&lt;&#x2F;code&gt; are available in &lt;code&gt;httm&lt;&#x2F;code&gt; version &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&#x2F;releases&#x2F;tag&#x2F;0.16.7&quot;&gt;0.16.7&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>ounce (codename: &#x27;dimebag&#x27;): Dynamic File-Level ZFS Snapshots</title>
		<published>2022-10-21T00:00:00+00:00</published>
		<updated>2022-10-23T00:00:00+00:00</updated>
		<link rel="alternate" href="/ounce/" type="text/html"/>
		<id>/ounce/</id>
		<content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&#x2F;blob&#x2F;master&#x2F;scripts&#x2F;ounce.zsh&quot;&gt;ounce&lt;&#x2F;a&gt; (codename: &amp;quot;dimebag&amp;quot;) is a wrapper script for &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&quot;&gt;httm&lt;&#x2F;a&gt; which give you no mental overhead, non-periodic dynamic snapshots.&lt;&#x2F;p&gt;
&lt;p&gt;On &lt;a href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33162259&quot;&gt;Hacker News&lt;&#x2F;a&gt;, there was an article about how NILFS seems to &amp;quot;take&amp;quot; continuous snapshots.  In addition to checkpoints, one can stop a NILFS filesystem from garbage collecting, roll back to a point in time, and recover a file that was once there.  And, this seems great, if you can take the performance hit of a log-structured file system (which is substantial).&lt;&#x2F;p&gt;
&lt;p&gt;But perhaps like my boy Ben Franklin (or was it my mother, or Ben Franklin&#x27;s mother?) said &amp;quot;an ounce of prevention is worth a pound of cure&amp;quot;?  Why not just take a snapshot before you do something silly?&lt;&#x2F;p&gt;
&lt;p&gt;For awhile, one has been able to just feed &lt;code&gt;httm&lt;&#x2F;code&gt; file names and have it figure out which dataset those files resided on.  Like so:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;➜  printf &amp;quot;&amp;#x2F;var&amp;#x2F;log&amp;#x2F;syslog\n&amp;#x2F;etc&amp;#x2F;passwd\n&amp;quot; | sudo httm --snap
httm took a snapshot named: rpool&amp;#x2F;var&amp;#x2F;log@snap_2022-10-21-08:57:04_httmSnapFileMount
httm took a snapshot named: rpool@snap_2022-10-21-08:57:04_httmSnapFileMount
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But I don&#x27;t know about you, I don&#x27;t usually feed file names into a pipe before I type &lt;code&gt;Name of $EDITOR redacted to prevent flame war&lt;&#x2F;code&gt; or &lt;code&gt;rm&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;p&gt;When I type:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# nano used here to frustrate just you
➜  nano &amp;#x2F;etc&amp;#x2F;samba&amp;#x2F;smb.conf
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If there is not a snapshot that matches the live version, I would like my computer to snapshot &lt;code&gt;&#x2F;etc&#x2F;samba&#x2F;smb.conf&lt;&#x2F;code&gt; before I do something stupid.  &lt;code&gt;ounce&lt;&#x2F;code&gt; does this for me and now for you.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# why do you hate nano so much?
➜  ounce nano &amp;#x2F;etc&amp;#x2F;samba&amp;#x2F;smb.conf
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;ounce&lt;&#x2F;code&gt; knows that it&#x27;s smart and I&#x27;m dumb, and sees that I just edited &lt;code&gt;&#x2F;etc&#x2F;samba&#x2F;smb.conf&lt;&#x2F;code&gt; a few short minutes ago and takes a snapshot before I edit the file again because it wants me to have snapshots of all my file changes.  You can check:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;➜  httm &amp;#x2F;etc&amp;#x2F;samba&amp;#x2F;smb.conf
─────────────────────────────────────────────────────────────────────────────────────────────────────────────
Tue Aug 09 16:46:14 2022  17.6 KiB  &amp;quot;&amp;#x2F;.zfs&amp;#x2F;snapshot&amp;#x2F;autosnap_2022-10-19_20:00:22_hourly&amp;#x2F;etc&amp;#x2F;samba&amp;#x2F;smb.conf&amp;quot;
Fri Oct 21 09:11:17 2022  17.6 KiB  &amp;quot;&amp;#x2F;.zfs&amp;#x2F;snapshot&amp;#x2F;snap_2022-10-21-09:11:18_httmSnapFileMount&amp;#x2F;etc&amp;#x2F;samba&amp;#x2F;smb.conf&amp;quot;
─────────────────────────────────────────────────────────────────────────────────────────────────────────────
Fri Oct 21 09:11:25 2022  17.6 KiB  &amp;quot;&amp;#x2F;etc&amp;#x2F;samba&amp;#x2F;smb.conf&amp;quot;
─────────────────────────────────────────────────────────────────────────────────────────────────────────────
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For more fun, simply alias to the commands you make modifications with:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# don&amp;#x27;t get triggered but...
alias nano=&amp;quot;ounce nano&amp;quot;
alias rm=&amp;quot;ounce rm&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now available in &lt;code&gt;httm&lt;&#x2F;code&gt; version &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&#x2F;releases&#x2F;tag&#x2F;0.16.1&quot;&gt;0.16.1&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Imagine You&#x27;re a Goofball: Dynamic Preventative ZFS Snapshots</title>
		<published>2022-10-19T00:00:00+00:00</published>
		<updated>2022-10-20T00:00:00+00:00</updated>
		<link rel="alternate" href="/dynamic/" type="text/html"/>
		<id>/dynamic/</id>
		<content type="html">&lt;p&gt;On &lt;a href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33162259&quot;&gt;Hacker News&lt;&#x2F;a&gt;, there is an article about how NILFS seems to &amp;quot;take&amp;quot; continuous snapshots.  In addition to checkpoints, one can stop a NILFS filesystem from garbage collecting, roll back to a point in time, and recover a file that was once there.  And, this seems great, if you can take the performance hit of a log-structured file system (which is substantial).&lt;&#x2F;p&gt;
&lt;p&gt;But perhaps like our mother&#x27;s said &amp;quot;an ounce of prevention is worth a pound of cure&amp;quot;?  Why not just take a snapshot before you do something silly?  With &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&quot;&gt;httm&lt;&#x2F;a&gt;, one can now take these sorts of no mental overhead, non-periodic dynamic snapshots, which can &lt;em&gt;complement&lt;&#x2F;em&gt; your current periodic snapshot scheme.&lt;&#x2F;p&gt;
&lt;p&gt;Let me reiterate -- one can and &lt;em&gt;should be able to&lt;&#x2F;em&gt; take a snapshot without needing to specify a dataset or snapshot name. Just feed &lt;code&gt;httm&lt;&#x2F;code&gt; a filename and &lt;code&gt;httm&lt;&#x2F;code&gt; will figure out the rest.&lt;&#x2F;p&gt;
&lt;p&gt;See, for example:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#!&amp;#x2F;bin&amp;#x2F;bash
function ounce_of_prevention {
    for a; do
        # is the argument a file?
        if [[ -f &amp;quot;$a&amp;quot; ]]; then
            local LIVE_FILE=&amp;quot;$a&amp;quot;
        else
            continue
        fi

        # get last snap version of the live file?
        local LAST_SNAP=&amp;quot;$(httm -l &amp;quot;$LIVE_FILE&amp;quot;)&amp;quot;

        # check whether to take snap - do we have a snap of the live file already?
        # 1) if empty, live file does not have a snapshot, then take snap, or
        # 2) if live file is not the same as the last snap, then take snap
        if [[ -z &amp;quot;$LAST_SNAP&amp;quot; ]] || \
           [[ ! -z &amp;quot;$LAST_SNAP&amp;quot; &amp;amp;&amp;amp; &amp;quot;$(stat -c %Y &amp;quot;$LIVE_FILE&amp;quot;)&amp;quot; -ne &amp;quot;$(stat -c %Y &amp;quot;$LAST_SNAP&amp;quot;)&amp;quot; ]]
        then
            # httm will dynamically determine the location of
            # the file&amp;#x27;s ZFS dataset and snapshot that mount
            sudo httm --snap &amp;quot;$LIVE_FILE&amp;quot; &amp;gt; &amp;#x2F;dev&amp;#x2F;null &amp;amp;
        fi
    done
}

ounce_of_prevention &amp;quot;$@&amp;quot;
# expressly used `nano` instead of `vim` or `emacs` to avoid a unholy war
&amp;#x2F;usr&amp;#x2F;bin&amp;#x2F;nano &amp;quot;$@&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we check whether we even need to take a snapshot:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The 0th condition checks whether an argument is a file.&lt;&#x2F;li&gt;
&lt;li&gt;The command &lt;code&gt;httm -l $LIVE_FILE&lt;&#x2F;code&gt; requests the last snapshot for the file, allowing you to test the 1st condition, which checks whether that file has a snapshot, and,&lt;&#x2F;li&gt;
&lt;li&gt;The 2nd condition checks whether the live file is not the same as the last snapshot version.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Next, &lt;code&gt;httm&lt;&#x2F;code&gt; makes certain that it doesn&#x27;t matter whether you are editing &lt;code&gt;~&#x2F;.zshrc&lt;&#x2F;code&gt; or &lt;code&gt;&#x2F;etc&#x2F;samba&#x2F;smb.conf&lt;&#x2F;code&gt;.  &lt;code&gt;httm&lt;&#x2F;code&gt; dynamically determines and snapshots the appropriate mount (before you modify&#x2F;screw up the file!).&lt;&#x2F;p&gt;
&lt;p&gt;Now, one will have to also set up a bash alias (&lt;code&gt;alias nano=nano-with-prevention&lt;&#x2F;code&gt;), and a sudoers policy (&lt;code&gt;kimono ALL=(ALL) NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;httm --snap&lt;&#x2F;code&gt;), which allows these types of dynamic snapshots, but this pattern does seem to work pretty well.&lt;&#x2F;p&gt;
&lt;p&gt;Does anyone else have any other fancy dynamic snapshot tricks I could add to my arsenal?&lt;&#x2F;p&gt;
&lt;p&gt;The latest release of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&quot;&gt;httm&lt;&#x2F;a&gt; is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&#x2F;releases&#x2F;tag&#x2F;0.16.0&quot;&gt;0.16.0&lt;&#x2F;a&gt;. &lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Using `httm` and ZFS to detect file modifications for `dano` (or getting a little sleazy to do a little good)</title>
		<published>2022-10-10T00:00:00+00:00</published>
		<updated>2022-10-10T00:00:00+00:00</updated>
		<link rel="alternate" href="/dano/" type="text/html"/>
		<id>/dano/</id>
		<content type="html">&lt;p&gt;One thing ZFS doesn&#x27;t do (and thank goodness it doesn&#x27;t?), it doesn&#x27;t detect out-of-band changes to files.  If a program has the permissions to modify a file, ZFS happily modifies that file.  But, for some files (and for the truly paranoid), we may want to keep additional metadata about file integrity.  For instance, FLAC files keep checksums of its music streams. A program I wrote, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;dano&quot;&gt;dano&lt;&#x2F;a&gt;, provides a way to do the same for all FFMPEG compatible media streams.&lt;&#x2F;p&gt;
&lt;p&gt;And perhaps you want to read back and verify such media bitstreams occasionally as one might in a &lt;code&gt;zpool scrub&lt;&#x2F;code&gt;, of course &lt;code&gt;dano&lt;&#x2F;code&gt; lets you do that too:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;% find &amp;#x2F;tank&amp;#x2F;Media -type f | dano --test
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But doesn&#x27;t verifying &lt;em&gt;all those checksums&lt;&#x2F;em&gt; take a long time?  And don&#x27;t you already do this when you do a &lt;code&gt;zpool scrub&lt;&#x2F;code&gt;?  Good point!  Wouldn&#x27;t it be nice to only test those files which ZFS tells us have changed (if you trust ZFS)?  Is it wrong&#x2F;sleazy to not verify these checksums if we know the underlying bits haven&#x27;t changed?  Maybe &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&quot;&gt;httm&lt;&#x2F;a&gt; can help us be a little sleazy:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;% httm --num-versions ~&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;*
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;Cargo.lock&amp;quot; : 3 Versions available.
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;Cargo.toml&amp;quot; : 4 Versions available.
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;LICENSE&amp;quot; : 1 Version available.
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;README.md&amp;quot; : 2 Versions available.
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;httm.1&amp;quot; : 3 Versions available.
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;packaging&amp;quot; : 1 Version available.
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;scripts&amp;quot; : 1 Version available.
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;src&amp;quot; : 6 Versions available.
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;target&amp;quot; : 1 Version available
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Of course, this is really great for determining, at a glace, &amp;quot;Wow, some of these files in &lt;code&gt;&#x2F;etc&lt;&#x2F;code&gt; are seeing lot&#x27;s of churn.  I have more questions...&amp;quot;.  But maybe what I really want, right now, is files with a single version available but which have been around long enough to have at least one snapshot available, &lt;code&gt;httm&lt;&#x2F;code&gt; has you covered:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;% httm --num-versions=single-with-snap ~&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;*
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;LICENSE&amp;quot;
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;packaging&amp;quot;
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;scripts&amp;quot;
&amp;quot;&amp;#x2F;srv&amp;#x2F;program&amp;#x2F;httm&amp;#x2F;target&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And we might now also rewrite our little &lt;code&gt;dano&lt;&#x2F;code&gt; script to verify only those files with multiple versions that ZFS detected:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;% find &amp;#x2F;tank&amp;#x2F;Media -type f | httm --num-versions=multiple | dano --test
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Available in &lt;code&gt;httm&lt;&#x2F;code&gt; version &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&#x2F;releases&#x2F;tag&#x2F;0.15.2&quot;&gt;0.15.2&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Fun with ZFS, httm, and inotifywait</title>
		<published>2022-06-25T00:00:00+00:00</published>
		<updated>2022-06-25T00:00:00+00:00</updated>
		<link rel="alternate" href="/inotifywait/" type="text/html"/>
		<id>/inotifywait/</id>
		<content type="html">&lt;p&gt;If you&#x27;ve never used &lt;code&gt;inotifywait&lt;&#x2F;code&gt;, it&#x27;s pretty handy for when you want to snapshot a directory after a file is accessed, or written to, or moved to a watched directory, etc., like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;inotifywait -r -m --exclude &amp;quot;&amp;#x2F;srv&amp;#x2F;downloads&amp;#x2F;incomplete&amp;#x2F;&amp;quot; -e moved_to &amp;quot;&amp;#x2F;srv&amp;#x2F;downloads&amp;#x2F;&amp;quot; | while read -r line; do
	sudo &amp;#x2F;usr&amp;#x2F;sbin&amp;#x2F;zfs snapshot rpool&amp;#x2F;downloads@snap_&amp;quot;$( &amp;#x2F;bin&amp;#x2F;date +%F-%T )&amp;quot;_completionSnap
done
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, imagine you&#x27;re watching a large directory tree where there may be many ZFS datasets, how would you know which dataset to snapshot?&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&quot;&gt;httm&lt;&#x2F;a&gt; has your back!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;httm -m &amp;lt;INPUT_FILE&amp;gt;&lt;&#x2F;code&gt; will detect and report back the mount of the ZFS dataset upon which that watched file resides, so you can use that mount&#x2F;dataset in your snapshot scripts:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;inotifywait -r -m --format %w%f --exclude &amp;quot;&amp;#x2F;srv&amp;#x2F;downloads&amp;#x2F;incomplete&amp;#x2F;&amp;quot; -e moved_to &amp;quot;&amp;#x2F;srv&amp;#x2F;downloads&amp;#x2F;&amp;quot; | while read -r line; do
	filemount=&amp;quot;$(httm -m $line)&amp;quot; 
	filedataset=&amp;quot;$(mount | grep $filemount | cut -f1 -d&amp;#x27; &amp;#x27;)&amp;quot; 
	sudo &amp;#x2F;usr&amp;#x2F;sbin&amp;#x2F;zfs snapshot $filedataset@snap_&amp;quot;$( &amp;#x2F;bin&amp;#x2F;date +%F-%T )&amp;quot;_completionSnap 
done
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you&#x27;re comfortable with &lt;code&gt;httm&lt;&#x2F;code&gt; making a few choices for you, &lt;code&gt;httm&lt;&#x2F;code&gt; can also take a snapshot from using just the filename as input:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;% sudo httm --snap &amp;#x2F;var&amp;#x2F;log&amp;#x2F;syslog
httm took a snapshot named: rpool&amp;#x2F;ROOT&amp;#x2F;ubuntu_wi01vc&amp;#x2F;var&amp;#x2F;log@snap_Jun-25-2022-23:11:50_httmSnapFileMount
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This last feature is ZFS only for right now.&lt;&#x2F;p&gt;
&lt;p&gt;Available now for &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kimono-koans&#x2F;httm&#x2F;releases&#x2F;tag&#x2F;0.12.6&quot;&gt;0.12.6&lt;&#x2F;a&gt; and later editions.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Re: packaging, FOSS user expectations are out of alignment</title>
		<published>2022-06-07T00:00:00+00:00</published>
		<updated>2022-06-07T00:00:00+00:00</updated>
		<link rel="alternate" href="/user-expectations/" type="text/html"/>
		<id>/user-expectations/</id>
		<content type="html">&lt;p&gt;Usually when asked to build a package for your particular distribution, I say, &amp;quot;I&#x27;m afraid I just don&#x27;t have the time, but PRs for your distribution are welcome.&amp;quot;  But my real talk, B-side opinion on FOSS packaging, is -- when you ask a dev to package software in a specific way for you, in the FOSS world, that&#x27;s entitlement, because you can do it yourself.&lt;&#x2F;p&gt;
&lt;p&gt;Of course, you may &lt;em&gt;refuse to use&lt;&#x2F;em&gt; packages that aren&#x27;t natively packaged just the way you like. But -- for me -- it crosses a line when one whines about the packages that are available. &amp;quot;Ugh, only Flatpak (or deb, or rpm), how dare you, the dev, not pay attention to my tastes after I&#x27;ve done &lt;em&gt;nothing&lt;&#x2F;em&gt;, contributed &lt;em&gt;nothing&lt;&#x2F;em&gt;.&amp;quot;&lt;&#x2F;p&gt;
&lt;p&gt;Because one should &lt;em&gt;build a package&lt;&#x2F;em&gt; or two before they are entitled to an opinion about the packaging a dev uses for their personal project.  Why?  Because packaging sucks. It&#x27;s the last thing anyone wants to do. And when you do make a package, and no one is happy, it sucks even more.&lt;&#x2F;p&gt;
&lt;p&gt;A few common refrains and my feelings --&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;What no pkgsrc?&amp;quot; &amp;quot;Where&#x27;s my PKGBUILD?&amp;quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;I use&#x2F;like pkgsrc and have used PKGBUILD and think it&#x27;s pretty neat, but I think we all know these are fairly niche systems.  People&#x2F;users who use fairly niche systems should be the first to take responsibility for them, and not expect someone else to do it for them.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Just figure out my preferred packaging and distribution system (I have no idea but I imagine it&#x27;s easy).&amp;quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Why?  The software builds on my system just fine, and there are instructions for you to build it yourself.  &amp;quot;But you want me as a user...&amp;quot;  Explain this to me -- do I want anyone as a user who is not willing to build their own package for their distribution&#x2F;OS?  Because that user &lt;em&gt;tends to be&lt;&#x2F;em&gt; more of a consumer (who doesn&#x27;t pay) than a valued community member.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;The package you distribute doesn&#x27;t work on my slightly different system.&amp;quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;I totally sympathize, but this is the problem with packaging.  You ship one binary with one dependency, say libc, and guess what?  Debian 10 or whatever decides to use a version that is way older than what Ubuntu uses.  I guess we need 3 more Debian packages then...  Yeesh.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Snap&#x2F;Flatpak&#x2F;AppImage sucks.&amp;quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Maybe.  At least they allow you to easily ship your dependencies.  The concept seems quite nice when: 1) there are multiple packaging models to be covered, 2) distribution maintainers are overworked and aren&#x27;t packaging your software for you, and 3) their distribution&#x27;s users aren&#x27;t helping you or them out either.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Workflow: ZFS snapshot-ed file versions to tar and git archives with httm</title>
		<published>2022-05-07T00:00:00+00:00</published>
		<updated>2022-05-07T00:00:00+00:00</updated>
		<link rel="alternate" href="/git/" type="text/html"/>
		<id>/git/</id>
		<content type="html">&lt;p&gt;For most non-programming tasks, no one actually wants to work within a git repo.  While git repos offer many benefits, including interoperating with the git ecosystem, most of the time, they&#x27;re just &lt;em&gt;too heavy weight&lt;&#x2F;em&gt; for most system administration tasks.&lt;&#x2F;p&gt;
&lt;p&gt;Imagine you could have many of those same benefits, but only &lt;em&gt;when you need them&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Maybe you already know what to do when you want to send all snapshot-ed versions of your &lt;code&gt;syslog&lt;&#x2F;code&gt; via email:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;httm -n &amp;#x2F;var&amp;#x2F;log&amp;#x2F;syslog | tar -zcvf all-versions-syslog.tar.gz -T -
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But imagine something a little more difficult.  Imagine you&#x27;ve misconfigured your &lt;code&gt;sysctl.conf&lt;&#x2F;code&gt; and you have just the pal you know knows how to fix it, but she&#x27;s a half-a-world away.  You think -- &lt;em&gt;who wants to dig through 10+ file versions&lt;&#x2F;em&gt; to identify the source of the error?  Wouldn&#x27;t it be nice if she could see your changes as you made them incrementally?&lt;&#x2F;p&gt;
&lt;p&gt;Use &lt;code&gt;httm&lt;&#x2F;code&gt; and this just works:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# create variable for file name
file=&amp;quot;&amp;#x2F;etc&amp;#x2F;sysctl.conf&amp;quot;
# create git repo
mkdir .&amp;#x2F;archive-git; cd .&amp;#x2F;archive-git; git init
# copy each file version to repo and commit after each copy
for version in $(httm -n $file); do 
	cp &amp;quot;$version&amp;quot; .&amp;#x2F; 
	git add &amp;quot;.&amp;#x2F;$(basename $version)&amp;quot; 
	git commit -m &amp;quot;$(stat -c %y $version)&amp;quot;
done
# create git tar.gz archive in the parent directory
git archive --format=tar.gz -o &amp;quot;..&amp;#x2F;archive-git-$(basename $file).tar.gz&amp;quot; master; cd ..&amp;#x2F;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And to view the your changes incrementally:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;tar zxvf archive-git-sysctl.conf.tar.gz 
cd .&amp;#x2F;archive-git
git log -p
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Is there a Unix-y workflow you&#x27;d like to see covered by &lt;code&gt;httm&lt;&#x2F;code&gt;?  Let me know!&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
